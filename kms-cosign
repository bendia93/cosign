---

## âœ… Objectif

> Permettre Ã  cosign d'accÃ©der **de maniÃ¨re sÃ©curisÃ©e** Ã  un KMS (AWS, Azure, Conjur, Vaultâ€¦) **depuis un environnement personnalisÃ©**, sans exposer de secrets statiques, et en respectant les principes DevSecOps.

---

## ğŸ” 1. **Cas 1 : Tu es dans un environnement *on-premise* ou *hybride AWS***

### ğŸ”’ Option sÃ©curisÃ©e : **Assumer un rÃ´le IAM temporairement**

> ğŸ”§ Utilise `aws sts assume-role` pour ne pas stocker de clÃ© dâ€™accÃ¨s

```bash
aws sts assume-role \
  --role-arn arn:aws:iam::<account_id>:role/CosignSigner \
  --role-session-name cosign-session
```

Tu obtiens :

* `AccessKeyId`
* `SecretAccessKey`
* `SessionToken`

â¡ï¸ Exporte-les temporairement :

```bash
export AWS_ACCESS_KEY_ID=...
export AWS_SECRET_ACCESS_KEY=...
export AWS_SESSION_TOKEN=...
```

Tu peux maintenant faire :

```bash
cosign sign --key awskms://us-east-1/alias/cosign-key ghcr.io/mon/image:tag
```

> âœ… Aucun secret stockÃ©, tout est temporaire et traÃ§able via CloudTrail.

---

## â˜ï¸ 2. **Cas 2 : Tu es en environnement *Azure non managÃ©***

### ğŸ”’ Option sÃ©curisÃ©e : **Azure Service Principal avec certificat ou workload identity**

#### Auth via certificat (pas mot de passe) :

1. GÃ©nÃ¨re un certificat pour ton SPN
2. Enregistre-le dans Azure AD
3. Utilise `az login --service-principal` avec `--cert`

```bash
az login --service-principal \
  --username <appId> \
  --tenant <tenantId> \
  --cert /path/to/cert.pem
```

Tu peux ensuite faire :

```bash
cosign sign --key azkms://myvault.vault.azure.net/keys/cosign-key ...
```

#### Ou utilise **Workload Identity Federation** (plus sÃ©curisÃ©, pas de secrets du tout) :

* Compatible GitHub Actions, Kubernetes, etc.
* Authentification via `oidc` automatique.

---

## ğŸ” 3. **Cas 3 : Tu utilises CyberArk Conjur (ou HashiCorp Vault)**

### ğŸ”’ SÃ©curitÃ© recommandÃ©e : **JWT Authenticator ou TLS Authenticator**

#### Exemple avec JWT (Kubernetes, GitHub Actions, etc.) :

* Conjur valide le token OIDC/JWT Ã©mis par ton provider (GitHub OIDC, K8s service account, etc.)
* Ton app peut rÃ©cupÃ©rer la clÃ© avec :

```bash
conjur authn-jwt login \
  --token "$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
```

Puis :

```bash
conjur variable get -i path/to/cosign.key > /tmp/key
cosign sign --key file:///tmp/key ...
```

> âœ… Pas de secrets statiques, auditables, intÃ©grables Ã  tous les environnements.

---

## ğŸ›¡ï¸ RÃ©sumÃ© des options sÃ©curisÃ©es selon contexte

| Environnement          | AccÃ¨s KMS SÃ©curisÃ©                       | Secret stockÃ© ? | Audit possible |
| ---------------------- | ---------------------------------------- | --------------- | -------------- |
| AWS hybride/on-prem    | `sts assume-role` + vars temporaires     | âŒ               | âœ… CloudTrail   |
| Azure externe          | SPN + cert / Workload Identity           | âŒ               | âœ…              |
| Kubernetes             | ServiceAccount + IRSA / MSI / JWT        | âŒ               | âœ…              |
| GitHub Actions         | OIDC + federated credentials (AWS/Azure) | âŒ               | âœ…              |
| Conjur (on-prem/cloud) | Authenticator JWT / TLS + rotation       | âŒ               | âœ…              |


----------------------------
Oui, tu **peux tout Ã  fait te passer de Fulcio et Rekor** si tu utilises **Cosign en mode "clÃ© privÃ©e gÃ©rÃ©e localement ou par un KMS"**. Câ€™est un mode **"clÃ© hors TUF/Sigstore"** et totalement **autonome**, ce qui est souvent prÃ©fÃ©rÃ© en environnement **industriel, souverain ou isolÃ©** (air-gapped, cloud privÃ©, etc.).

---

## âœ… 1. Ce que font Fulcio et Rekor

| Composant  | RÃ´le dans la chaÃ®ne Sigstore                                              | Peut-on sâ€™en passer ?                                     |
| ---------- | ------------------------------------------------------------------------- | --------------------------------------------------------- |
| **Fulcio** | Fournit une **clÃ© Ã©phÃ©mÃ¨re liÃ©e Ã  une identitÃ© OIDC** (GitHub, GCP, etc.) | âœ… Oui, si tu as ta propre clÃ© (KMS, fichier, HSM)         |
| **Rekor**  | Est un **transparency log** (registre public dâ€™empreintes de signatures)  | âœ… Oui, si tu ne veux pas publier dans un registre externe |

---

## ğŸ” 2. Cas dâ€™usage sans Fulcio/Rekor

### âœ… Exemple : signer une image Docker avec un KMS sans Fulcio/Rekor

```bash
cosign sign \
  --key awskms://us-east-1/alias/cosign-key \
  myregistry.com/mon/image:latest
```

> ğŸ”’ Cosign utilise ta clÃ© KMS pour signer. Aucun appel Ã  Fulcio.
> ğŸ—‚ï¸ La signature est enregistrÃ©e comme **attestation OCI** dans ton registre privÃ© (pas dans Rekor).

### âœ… Exemple : vÃ©rifier sans Rekor

```bash
cosign verify \
  --key awskms://us-east-1/alias/cosign-key \
  myregistry.com/mon/image:latest
```

> ğŸ” Cosign va chercher la signature dans le registre OCI, pas dans Rekor.

---

## ğŸ” 3. Quand Fulcio/Rekor deviennent utiles

Tu **aurais besoin de Fulcio/Rekor** si tu veux :

* ğŸ¤ **Signer sans gÃ©rer de clÃ©** (clÃ© Ã©phÃ©mÃ¨re gÃ©nÃ©rÃ©e automatiquement via Fulcio)
* ğŸ” **Auditer publiquement toutes les signatures** (Rekor = log append-only)
* ğŸ” Utiliser le systÃ¨me Sigstore complet avec **OIDC** (GitHub, Google, Azure)

---

## ğŸ› ï¸ 4. RÃ©sumÃ© â€“ Cosign sans Fulcio/Rekor

| Fonction          | Fulcio/Rekor            | Sans Fulcio/Rekor                |
| ----------------- | ----------------------- | -------------------------------- |
| GÃ©nÃ©ration de clÃ© | Fulcio (clÃ© temporaire) | ClÃ© stockÃ©e (KMS, fichier, HSM)  |
| Signature         | Signer + push Rekor     | Signer uniquement                |
| VÃ©rification      | ClÃ© + Rekor log         | ClÃ© + registre OCI               |
| Cas dâ€™usage       | Cloud DevSecOps         | CI/CD souverain, air-gapped, KMS |

---

## â“ Tu veux aller plus loin ?

Je peux te gÃ©nÃ©rer un **setup complet Cosign avec KMS (sans Fulcio/Rekor)** :

* ClÃ© AWS KMS, Azure, Vault ou Conjur
* Signature dâ€™image
* Pipeline CI/CD GitHub ou Jenkins
* VÃ©rification dans Kubernetes (Kyverno, OPA, etc.)


